{
  function F(name, args) {
    var args = [].slice.call(arguments)
    var name = args.shift()
    return new Fn(new Id(name), args)
  }
  
  function B(block) { return new Block(block) }
  function T(items) { return new Tuple(items) }
  function I(id)    { return new Id(name, sigil) }
}

start
  = __ program:Program __ { return program }

Program
  = elements:SourceElements? {
      return elements !== null ? elements : []
    }

SourceElements
  = head:SourceElement tail:(__ SourceElement)* {
      return new Block(rollup(head, tail))
    }

SourceElement
  = Assignment
  / Definition
  / Expression

Definition
  = 'def'i _ id:Identifier __ block:SourceElements __ 'end def'i { return F('def', id.name, block) }

Assignment
  = l:Identifier _ '=' __ r:Expression { return F('def', l.name, r) }
  
Expression
  = l:Identifier _ r:Expression { return new Fn(l, r) }
  / ValueList

ValueList
  = l:Value _ ',' __ r:ValueList { return flatten(l, r) }
  / Value

Value
  = Additive
  / Conditional
  / Identifier

Conditional
  = 'if'i _ cond:Expression _
    'then'i _ thenExpr:Expression _
    elseExpr:('else'i _ Expression _)?
    'end if'i?
    { return F('if', cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }
  / 'if'i __ cond:Expression __
    'then'i __ thenExpr:Expression __
    elseExpr:('else'i __ Expression __)?
    'end if'i
    { return F('if', cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }

Additive
  = l:Modulative _ "+" _ r:Additive { return F('+', l, r) }
  / l:Modulative _ "-" _ r:Additive { return F('-', l, r) }
  / Modulative
  
Modulative
  = l:Multiplicative _ "\\" _ r:Modulative { return F('\\', l, r) }
  / l:Multiplicative _ "mod"i _ r:Modulative { return F('mod', l, r) }
  / Multiplicative

Multiplicative
  = l:Comparative _ "*" _ r:Multiplicative { return F('*', l, r) }
  / l:Comparative _ "/" _ r:Multiplicative { return F('/', l, r) }
  / l:Comparative _ "รท" _ r:Multiplicative { return F('/', l, r) }
  / Comparative

Comparative
  = l:Equality _ "<" _ r:Comparative { return F('<', l, r) }
  / l:Equality _ ">" _ r:Comparative { return F('>', l, r) }
  / Equality

Equality
  = l:Primary _ '==' _ r:Equality { return F('==', l, r) }
  / l:Primary _ '=' _ r:Equality { return F('==', l, r) }
  / Primary

Primary
  = Integer
  / '(' valueList:ValueList ')' { return new Tuple(flatten(valueList)) }
  / "(" value:Value ")" { return value; }
  / String
  / Identifier

Integer "integer"
  = digits:[0-9]+ { return jsInt(digits)  }

String
  = '"' string:[^"]+ '"' { return jsStr(string); }
  / SymbolName
  / InterpolableString

InterpolableString
  = '@"' string:InterpolableStringChar * '"' { return string.join(''); }

InterpolableStringChar
  = '@{' expr:Additive '}' { return expr }
  / string:[^@"]+ { return string.join('') }

Identifier
  = TypedIdentifier
  / BareIdentifier

TypedIdentifier
  = id:IdentifierName sigil:TypeSigil { return new Id(id, sigil) }

BareIdentifier
  = id:IdentifierName { return new Id(id) }

IdentifierName
  = !Keyword str:[a-zA-Z_]+ { return str.join('') }

SymbolName
  = str:('#' [a-zA-Z_0-9]+) { return str.join('') }

TypeSigil
  = '$'
  / '%'
  / '!'
  / '#'

Keyword
  = 'if'i
  / 'then'i
  / 'else'i
  / 'end'i
  / 'mod'i
  / 'def'i
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "'{" (!"'{" SourceCharacter)* "}'"

MultiLineCommentNoLineTerminator
  = "'{" (!("'{" / LineTerminator) SourceCharacter)* "}'"

SingleLineComment
  = "'" (!LineTerminator SourceCharacter)*

EOS
  = __ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / __ EOF

EOSNoLineTerminator
  = _ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / _ EOF

EOF
  = !.
