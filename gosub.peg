{
  function jsStr(a) { return a.join('') }
  function jsInt(a, base) { var base = base ? base : 10; return parseInt(a.join(''), base) }

  function rollup(head, tail) {
    var result = [head];
    for (var i = 0; i < tail.length; i++) { result.push(tail[i][1]); }
    return result;
  }
  
  Id = function(name, sigil) {
    this.name = name+(sigil ? sigil : '');
    this.sigil = sigil;
    this.toString = function() { return "«"+this.name+"»" }
  }

  Fn = function(id, args) {
    this.id = id
    this.args = args;
    this.toString = function() { return this.id.name+"("+args+")" }
  }
  
  Block = function(block) {
    var self = this
    this.block = block
    this.toString = function() { return "Block { "+this.block+" }" }
    this.apply = function(that, args) {
      return window.gosub.call(self)
    }
  }
  
  function F(name, args) {
    var args = [].slice.call(arguments)
    var name = args.shift()
    return new Fn(new Id(name), args);
  }
}

start
  = __ program:Program __ { return program; }

Program
  = elements:SourceElements? {
      return elements !== null ? elements : []
    }

SourceElements
  = head:SourceElement tail:(__ SourceElement)* {
      return new Block(rollup(head, tail))
    }

SourceElement
  = Assignment
  / Definition
  / Expression

Definition
  = 'def'i _ id:Identifier __ block:SourceElements __ 'end def'i { return F('def', id.name, block) }

Assignment
  = l:Identifier _ '=' _ r:Expression { return F('def', l.name, r) }
  
Expression
  = l:Identifier _ r:Expression { return new Fn(l, r) }
  / NonInvokingExpressionList

NonInvokingExpressionList
  = l:NonInvokingExpression _ ',' _ r:NonInvokingExpressionList { return [l, r] }
  / NonInvokingExpression

NonInvokingExpression
  = Additive
  / Conditional
  / Identifier

Conditional
  = 'if'i _ cond:Expression _
    'then'i _ thenExpr:Expression _
    elseExpr:('else'i _ Expression _)?
    'end if'i?
    { return F('if', cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }
  / 'if'i __ cond:Expression __
    'then'i __ thenExpr:Expression __
    elseExpr:('else'i __ Expression __)?
    'end if'i
    { return F('if', cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }

Additive
  = l:Modulative _ "+" _ r:Additive { return F('+', l, r) }
  / l:Modulative _ "-" _ r:Additive { return F('-', l, r) }
  / Modulative
  
Modulative
  = l:Multiplicative _ "\\" _ r:Modulative { return F('\\', l, r) }
  / l:Multiplicative _ "mod"i _ r:Modulative { return F('mod', l, r) }
  / Multiplicative

Multiplicative
  = l:Comparative _ "*" _ r:Multiplicative { return F('*', l, r) }
  / l:Comparative _ "/" _ r:Multiplicative { return F('/', l, r) }
  / l:Comparative _ "÷" _ r:Multiplicative { return F('/', l, r) }
  / Comparative

Comparative
  = l:Equality _ "<" _ r:Comparative { return F('<', l, r) }
  / l:Equality _ ">" _ r:Comparative { return F('>', l, r) }
  / Equality

Equality
  = l:Primary _ '==' _ r:Equality { return F('==', l, r) }
  / l:Primary _ '=' _ r:Equality { return F('==', l, r) }
  / Primary

Primary
  = Integer
  / "(" Additive:Additive ")" { return Additive; }
  / String
  / Identifier

Integer "integer"
  = digits:[0-9]+ { return jsInt(digits)  }

String
  = '"' string:[^"]+ '"' { return jsStr(string); }
  / InterpolableString

InterpolableString
  = '@"' string:InterpolableStringChar * '"' { return string.join(''); }

InterpolableStringChar
  = '@{' expr:Additive '}' { return expr }
  / string:[^@"]+ { return string.join('') }

Identifier
  = TypedIdentifier
  / BareIdentifier

TypedIdentifier
  = id:IdentifierName sigil:TypeSigil { return new Id(id, sigil) }

BareIdentifier
  = id:IdentifierName { return new Id(id) }

IdentifierName
  = !Keyword str:[a-zA-Z_]+ { return str.join('') }

TypeSigil
  = '$'
  / '%'
  / '!'
  / '#'

Keyword
  = 'if'i
  / 'then'i
  / 'else'i
  / 'end'i
  / 'mod'i
  / 'def'i
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "'{" (!"'{" SourceCharacter)* "}'"

MultiLineCommentNoLineTerminator
  = "'{" (!("'{" / LineTerminator) SourceCharacter)* "}'"

SingleLineComment
  = "'" (!LineTerminator SourceCharacter)*

EOS
  = __ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / __ EOF

EOSNoLineTerminator
  = _ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / _ EOF

EOF
  = !.
