{
  var scope = {};
  scope['hello'] = 'ohai';
  scope['print'] = function(str) { console.log(str) }

  function jsStr(a) { return a.join('') }
  function jsInt(a) { return parseInt(a.join(''), 10) }

  function rollup(head, tail) {
    var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
  }
  
  invocation = function(fn, args) {
    this.fn = fn;
    this.args = args;
    this.call = function(scope) { resolve(scope, fn)(resolve(scope, args)) }
    this.toString = function() { return fn+"("+args+")"; }
  }
  
  identifier = function(name, sigil) {
    this.sigil = sigil;
    this.name = name;
    this.toString = function() { return "«"+this.name+(this.sigil ? this.sigil : '')+"»" }
  }

  F = {
    if: function(cond, thenExpr, elseExpr) {
      this.toString = function() { return cond+" ? "+thenExpr+" : "+elseExpr }
    },
    '<': function(l, r) {
      this.toString = function() { return l+"<"+r }
    },
    '>': function(l, r) {
      this.toString = function() { return l+">"+r }
    },
    '+': function(l, r) {
      this.toString = function() { return l+"+"+r }
    },
    '-': function(l, r) {
      this.toString = function() { return l+"-"+r }
    },
    '\\': function(l, r) {
      this.toString = function() { return l+"\\"+r }
    },
    'mod': function(l, r) {
      this.toString = function() { return l+" mod "+r }
    },
    '*': function(l, r) {
      this.toString = function() { return l+"*"+r }
    },
    '/': function(l, r) {
      this.toString = function() { return l+"/"+r }
    },
  }
}

start
  = __ program:Program __ { return program; }

Program
  = elements:SourceElements? {
      return elements !== null ? elements : []
    }

SourceElements
  = head:SourceElement tail:(__ SourceElement)* {
      return rollup(head, tail)
    }

SourceElement
  = Invocation
  
Invocation
  = left:Identifier _ right:Expression { return new invocation(left, right) }
  / Expression

Expression
  = Additive
  / Conditional
  / Identifier

Conditional
  = 'if' _ cond:Expression _
    'then' _ thenExpr:Expression _
    elseExpr:('else' _ Expression _)?
    'end if'?
    { return new F.if(cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }
  / 'if' __ cond:Expression __
    'then' __ thenExpr:Expression __
    elseExpr:('else' __ Expression __)?
    'end if'
    { return new F.if(cond, thenExpr, elseExpr !== null ? elseExpr[2] : null) }

Additive
  = l:Modulative "+" r:Additive { return new F['+'](l, r); }
  / l:Modulative "-" r:Additive { return new F['-'](l, r); }
  / Modulative
  
Modulative
  = l:Multiplicative "\\" r:Modulative { return new F['\\'](l, r); }
  / l:Multiplicative "mod" r:Modulative { return new F['mod'](l, r); }
  / Multiplicative

Multiplicative
  = l:Primary "*" r:Multiplicative { return new F['*'](l, r); }
  / l:Primary "/" r:Multiplicative { return new F['/'](l, r); }
  / l:Primary "÷" r:Multiplicative { return new F['/'](l, r); }
  / Comparative

Comparative
  = l:Primary "<" r:Primary { return new F['<'](l, r); }
  / l:Primary ">" r:Primary { return new F['>'](l, r); }
  / Primary

Primary
  = Integer
  / "(" Additive:Additive ")" { return Additive; }
  / String
  / Identifier

Integer "integer"
  = digits:[0-9]+ { return jsInt(digits)  }

String
  = '"' string:[^"]+ '"' { return jsStr(string); }
  / InterpolableString

InterpolableString
  = '@"' string:InterpolableStringChar * '"' { return string.join(''); }

InterpolableStringChar
  = '@{' expr:Additive '}' { return expr }
  / string:[^@"]+ { return string.join('') }

Identifier
  = TypedIdentifier
  / BareIdentifier

TypedIdentifier
  = id:IdentifierName sigil:TypeSigil { return new identifier(id, sigil) }

BareIdentifier
  = id:IdentifierName { return new identifier(id) }

IdentifierName
  = !Keyword str:[a-zA-Z_]+ { return str.join('') }

TypeSigil
  = '$'
  / '%'
  / '!'
  / '#'

Keyword
  = 'if'
  / 'then'
  / 'else'
  / 'end'
  / 'mod'
_
  = (WhiteSpace / MultiLineCommentNoLineTerminator / SingleLineComment)*

__
  = (WhiteSpace / LineTerminatorSequence / Comment)*

SourceCharacter
  = .

WhiteSpace "whitespace"
  = [\t\v\f \u00A0\uFEFF]

LineTerminator
  = [\n\r\u2028\u2029]

LineTerminatorSequence "end of line"
  = "\n"
  / "\r\n"
  / "\r"
  / "\u2028" // line separator
  / "\u2029" // paragraph separator

Comment "comment"
  = MultiLineComment
  / SingleLineComment

MultiLineComment
  = "'{" (!"'{" SourceCharacter)* "}'"

MultiLineCommentNoLineTerminator
  = "'{" (!("'{" / LineTerminator) SourceCharacter)* "}'"

SingleLineComment
  = "'" (!LineTerminator SourceCharacter)*

EOS
  = __ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / __ EOF

EOSNoLineTerminator
  = _ ":"
  / _ LineTerminatorSequence
  / _ &"end if"
  / _ EOF

EOF
  = !.
